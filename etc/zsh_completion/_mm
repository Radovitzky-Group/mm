#compdef mm
# zsh completion for mm build system                        -*- shell-script -*-
#
# Installation:
#   Option 1: Copy to a directory in your $fpath
#     cp _mm /usr/local/share/zsh/site-functions/
#
#   Option 2: Add the containing directory to fpath in your .zshrc
#     fpath=(/path/to/mm/etc/zsh_completion $fpath)
#     autoload -Uz compinit && compinit
#
#   Option 3: Source directly (not recommended)
#     source /path/to/mm/etc/zsh_completion/_mm
#
# Notes:
#   - Zsh displays descriptions inline in the completion menu natively,
#     so no F2 keybinding is needed (unlike the bash version).
#   - For the mm-target-help standalone command, add to your .zshrc:
#     autoload -Uz _mm && _mm  # or just source this file

# =============================================================================
# Global targets
# =============================================================================

# All targets that are always available regardless of project configuration.
# Extracted from make/mm/rules.mm, make/builder/rules.mm, etc.
# Format: 'target:description' for _describe
typeset -a _mm_global_target_specs=(
    'help:Show usage information'
    'mm.usage:Show usage information'
    'mm.banner:Print the mm version banner'
    'mm.config:Show makefile search path'
    'mm.info:Show important mm variables'
    'make.info:Show GNU Make variables'
    'builder.info:Show builder directory layout'
    'builder.info.help:List targets that print build layout'
    'builder.info.tmp:Show staging directory'
    'builder.info.prefix:Show install prefix'
    'builder.info.bin:Show bin directory'
    'builder.info.doc:Show doc directory'
    'builder.info.inc:Show include directory'
    'builder.info.lib:Show lib directory'
    'builder.info.share:Show share directory'
    'builder.info.pyc:Show Python bytecode directory'
    'builder.info.staging:Show staging directory'
    'platform.info:Show platform information (os, arch)'
    'host.info:Show host information (name, cores)'
    'user.info:Show user information (name, email)'
    'developer.info:Show developer options/overrides'
    'compilers.info:Show language-to-compiler map'
    'languages.info:List known languages'
    'suffixes.info:Show file extension to language map'
    'targets.info:Show target tag and variants'
    'extern.info:Show external package support'
    'extern.db.clean:Remove package database file'
    'projects:Build all projects'
    'projects.boot:Log build start and setup'
    'projects.shutdown:Log build finish'
    'projects.info:List known projects'
    'tests:Run all test suites'
    'tests.clean:Clean all test suites'
    'clean:Clean all projects and tests'
    'tidy:Delete backup files'
    'libraries.info:List known libraries'
    'packages.info:List known packages'
    'extensions.info:List known extensions'
    'tests.info:List known test suites'
    'docker-images.info:List known docker images'
    'webpack.info:List known webpack bundles'
    'vite.info:List known vite bundles'
)

# =============================================================================
# Per-asset target suffix tables
# =============================================================================

# Per-project suffixes (from make/projects/rules.mm)
typeset -a _mm_project_suffix_specs=(
    '.directories:Create required directories'
    '.assets:Build all assets'
    '.clean:Clean artifacts'
    '.info:Show metadata'
    '.info.contents:Show asset contents'
    '.help:Show documentation'
)

# Per-library suffixes (from make/libraries/rules.mm)
typeset -a _mm_library_suffix_specs=(
    '.clean:Clean artifacts'
    '.prerequisites:Build prerequisites'
    '.directories:Create required directories'
    '.assets:Build all assets'
    '.headers.gateway:Publish gateway headers'
    '.headers:Publish exported headers'
    '.autogen.cleanup:Clean up autogenerated files'
    '.cleangen:Remove autogenerated files'
    '.archive:Build static archive (.a)'
    '.dll:Build shared library (.so/.dylib)'
    '.info:Show metadata'
    '.info.directories:Show directory layout'
    '.info.sources:Show source files'
    '.info.sources.cuda:Show CUDA source files'
    '.info.headers:Show header files'
    '.info.objects:Show object files'
    '.info.objects.cuda:Show CUDA object files'
    '.info.incdirs:Show include directories'
    '.info.api:Show exported public headers'
    '.info.languages:Show source languages and flags'
    '.help:Show documentation'
)

# Per-package suffixes (from make/packages/rules.mm)
typeset -a _mm_package_suffix_specs=(
    '.clean:Clean artifacts'
    '.directories:Create required directories'
    '.assets:Build all assets'
    '.pyc:Byte-compile Python sources'
    '.drivers:Export driver scripts'
    '.config:Export configuration files'
    '.meta:Build package metadata'
    '.meta.source:Generate metadata .py source'
    '.info:Show metadata'
    '.info.directories:Show directory layout'
    '.info.sources:Show source files'
    '.info.pyc:Show byte-compiled files'
    '.info.pycdirs:Show byte-compile directories'
    '.info.config:Show configuration files'
    '.info.general:Show general metadata'
    '.info.package:Show package install path'
    '.info.meta:Show package metadata paths'
    '.help:Show documentation'
)

# Per-extension suffixes (from make/extensions/rules.mm)
typeset -a _mm_extension_suffix_specs=(
    '.prerequisites:Build prerequisites'
    '.directories:Create required directories'
    '.assets:Build all assets'
    '.extension:Build the .so module'
    '.clean:Clean artifacts'
    '.headers:Publish exported headers'
    '.archive:Build static archive (.a)'
    '.capsule:Publish capsule headers'
    '.module.init:Build module init from main'
    '.module.init.clean:Remove generated init file'
    '.info:Show metadata'
)

# Per-test-suite suffixes (from make/tests/rules.mm)
typeset -a _mm_testsuite_suffix_specs=(
    '.testcases:Build all test cases'
    '.clean:Clean artifacts'
    '.info:Show metadata'
    '.help:Show documentation'
    '.info.directories:Show directory layout'
    '.info.drivers:Show test case drivers'
    '.info.languages:Show source languages and flags'
    '.info.staging.targets:Show test make targets'
)

# Per-docker-image suffixes (from make/docker-images/rules.mm)
typeset -a _mm_docker_suffix_specs=(
    '.clean:Clean artifacts'
    '.build:Run docker build'
    '.run:Run docker container'
    '.launch:Run docker interactively'
    '.info:Show metadata'
    '.help:Show documentation'
)

# Per-webpack suffixes (from make/webpack/rules.mm)
typeset -a _mm_webpack_suffix_specs=(
    '.clean:Clean artifacts'
    '.generated:Build relay-generated bundle'
    '.chunks:Build external dependency chunks'
    '.generate.prep:Prepare for generation'
    '.static:Build static assets'
    '.config:Export configuration files'
    '.sources:Stage source files'
    '.npm_modules:Install npm dependencies'
    '.info:Show metadata'
    '.info.sources:Show source files'
    '.info.staged:List staged files'
    '.info.installed:List installed files'
    '.info.page:Show page paths'
    '.info.root:Show pack prefix'
    '.info.config:Show configuration files'
    '.info.client:Show client path'
    '.info.schema:Show schema path'
    '.info.staging:Show staging prefix'
    '.info.prefix:Show install prefix'
    '.help:Show documentation'
)

# Per-vite bundle suffixes (from make/vite/rules.mm)
typeset -a _mm_vite_suffix_specs=(
    '.config:Export configuration files'
    '.stage.config:Stage configuration files'
    '.stage.dirs:Create staging directories'
    '.stage.files:Stage source files'
    '.stage.modules:Install/update node modules'
    '.directories:Create required directories'
    '.staging.prefix:Create staging area'
    '.info:Show metadata'
    '.info.config:Show configuration files'
    '.help:Show documentation'
)

# Per-verbatim suffixes (from make/verbatim/rules.mm)
typeset -a _mm_verbatim_suffix_specs=(
    '.clean:Clean artifacts'
    '.info:Show metadata'
    '.info.files:List source files'
    '.info.staged.files:List staged files'
    '.info.directories:Show directory layout'
    '.info.staged.directories:List staged directories'
    '.help:Show documentation'
)

# =============================================================================
# Project configuration parsing helpers
# =============================================================================

# Find the project root by walking up from CWD looking for .mm/
_mm_find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" && -n "$dir" ]]; do
        if [[ -d "$dir/.mm" ]]; then
            echo "$dir"
            return
        fi
        dir="${dir:h}"
    done
}

# Find the mm installation directory by locating the make/ tree
_mm_find_mm_home() {
    # Try MM_HOME environment variable first
    if [[ -n "${MM_HOME:-}" && -d "$MM_HOME/make" ]]; then
        echo "$MM_HOME"
        return
    fi

    # Try to resolve from the mm command location
    local mm_path
    mm_path="${commands[mm]:-}"
    if [[ -n "$mm_path" ]]; then
        local resolved="${mm_path:A}"
        local mm_dir="${resolved:h}"

        if [[ -d "$mm_dir/make" ]]; then
            echo "$mm_dir"
            return
        fi
        local parent="${mm_dir:h}"
        if [[ -d "$parent/make" ]]; then
            echo "$parent"
            return
        fi
    fi

    # Try DV_DIR/mm (common user setup)
    if [[ -n "${DV_DIR:-}" && -d "$DV_DIR/mm/make" ]]; then
        echo "$DV_DIR/mm"
        return
    fi
}

# Get the project names from .mm/ directory
_mm_get_project_names() {
    local project_root=$1
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    local mmfile
    for mmfile in "$mm_dir"/*.mm(N); do
        echo "${mmfile:t:r}"
    done
}

# Parse all asset declarations from .mm config files
# Returns lines in format: "type|name"
_mm_parse_assets() {
    local project_root=$1
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    local config_file
    for config_file in "$mm_dir"/*.mm(N); do
        awk '
        /\.libraries[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "library|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "library|" a[i];
            }
        }
        /\.packages[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "package|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "package|" a[i];
            }
        }
        /\.extensions[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "extension|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "extension|" a[i];
            }
        }
        /\.tests[[:space:]]*:?=[[:space:]]/ {
            if ($0 ~ /\.tests\.[^[:space:]]+\./) next;
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "testsuite|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "testsuite|" a[i];
            }
        }
        /\.docker-images[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "docker|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "docker|" a[i];
            }
        }
        /\.webpack[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "webpack|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "webpack|" a[i];
            }
        }
        /\.vite[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "vite|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "vite|" a[i];
            }
        }
        /\.verbatim[[:space:]]*:?=[[:space:]]/ {
            sub(/^[^:+]*:?=[[:space:]]*/, "");
            gsub(/#.*/, "");
            n = split($0, a);
            for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "verbatim|" a[i];
            while ($0 ~ /\\[[:space:]]*$/) {
                if (getline <= 0) break;
                gsub(/#.*/, "");
                n = split($0, a);
                for (i = 1; i <= n; i++) if (a[i] != "" && a[i] !~ /\\/) print "verbatim|" a[i];
            }
        }
        ' "$config_file"
    done | sort -u
}

# =============================================================================
# Test target discovery (filesystem scan)
# =============================================================================

# Parse test suite configuration from .mm configuration files
# Returns lines in format: "stem|root"
_mm_parse_test_suites() {
    local project_root=$1
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    typeset -A suite_stems
    typeset -A suite_roots

    local config_file line
    for config_file in "$mm_dir"/*.mm(N) "$mm_dir"/*.tests(N); do
        [[ ! -f "$config_file" ]] && continue

        # Extract stem definitions
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            if [[ "$line" =~ '\.tst\.([^.]+)\.stem[[:space:]]*:=[[:space:]]*([^[:space:]#]+)' ]]; then
                suite_stems[${match[1]}]="${match[2]}"
            elif [[ "$line" =~ '\.tests\.([^.]+)\.stem[[:space:]]*:=[[:space:]]*([^[:space:]#]+)' ]]; then
                suite_stems[${match[1]}]="${match[2]}"
            fi
        done < <(grep -E '\.tst\.[^.]+\.stem\s*:=|\.tests\.[^.]+\.stem\s*:=' "$config_file" 2>/dev/null)

        # Extract root definitions
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            if [[ "$line" =~ '\.tst\.([^.]+)\.root[[:space:]]*:=[[:space:]]*([^[:space:]#]+)' ]]; then
                suite_roots[${match[1]}]="${match[2]}"
            elif [[ "$line" =~ '\.tests\.([^.]+)\.root[[:space:]]*:=[[:space:]]*([^[:space:]#]+)' ]]; then
                suite_roots[${match[1]}]="${match[2]}"
            fi
        done < <(grep -E '\.tst\.[^.]+\.root\s*:=|\.tests\.[^.]+\.root\s*:=' "$config_file" 2>/dev/null)
    done

    local suite
    for suite in ${(k)suite_stems}; do
        local stem="${suite_stems[$suite]}"
        local root="${suite_roots[$suite]:-tests/$stem/}"
        echo "$stem|$root"
    done
}

# Parse test exclusion patterns from .mm configuration files
_mm_get_exclusions() {
    local project_root=$1
    local stem=$2
    local mm_dir="$project_root/.mm"

    [[ ! -d "$mm_dir" ]] && return

    local exclusions=""
    local config_file

    for config_file in "$mm_dir"/*.mm(N) "$mm_dir"/*.tests(N); do
        [[ ! -f "$config_file" ]] && continue

        exclusions="$exclusions$(awk -v stem="$stem" '
            /\.tst\.[^.]+\.drivers\.exclude|\.tests\.[^.]+\.drivers\.exclude/ {
                if ($0 ~ ("\\." stem "\\.drivers\\.exclude")) {
                    sub(/^[^+:]*[+:]=[[:space:]]*/, "");
                    line = $0;
                    while (line ~ /\\[[:space:]]*$/) {
                        sub(/\\[[:space:]]*$/, "", line);
                        print line;
                        if (getline > 0) {
                            sub(/^[[:space:]]*/, "", $0);
                            line = $0;
                        } else {
                            break;
                        }
                    }
                    print line;
                }
            }
        ' "$config_file" 2>/dev/null | tr '\n' ' ')"
    done

    echo "$exclusions" | tr ' ' '\n' | grep -v '^$'
}

# Check if a test file matches any exclusion pattern
_mm_is_excluded() {
    local test_file=$1
    shift
    local exclusions=("$@")

    local pattern clean_pattern
    for pattern in "${exclusions[@]}"; do
        [[ -z "$pattern" ]] && continue
        clean_pattern="${pattern#*/}"

        if [[ "$test_file" == $~clean_pattern || "$test_file" == *"/$~clean_pattern" ]]; then
            return 0
        fi
    done
    return 1
}

# Generate test targets by scanning the test directories
_mm_get_test_targets() {
    local project_root=$1
    local suites
    suites="$(_mm_parse_test_suites "$project_root")"

    [[ -z "$suites" ]] && return

    local targets=()
    local stem root test_dir

    while IFS='|' read -r stem root; do
        [[ -z "$stem" || -z "$root" ]] && continue

        test_dir="${project_root}/${root%/}"
        [[ ! -d "$test_dir" ]] && continue

        # Get exclusions
        local excl_list=()
        local excl_line
        while IFS= read -r excl_line; do
            [[ -n "$excl_line" ]] && excl_list+=("$excl_line")
        done < <(_mm_get_exclusions "$project_root" "$stem")

        # Find test files
        local test_file rel_path no_ext target_prefix target_name
        target_prefix="${${root%/}//\//.}"

        for test_file in "$test_dir"/**/*.(cc|py|f90|f|c)(N); do
            rel_path="${test_file#$test_dir/}"

            if _mm_is_excluded "$rel_path" "${excl_list[@]}"; then
                continue
            fi

            no_ext="${rel_path%.*}"
            target_name="${target_prefix}.${no_ext//\//.}"
            targets+=("$target_name")
        done

        # Add subdirectory targets
        local subdir rel_subdir
        for subdir in "$test_dir"/**/*(N/); do
            rel_subdir="${subdir#$test_dir/}"
            [[ -z "$rel_subdir" ]] && continue
            targets+=("${target_prefix}.${rel_subdir//\//.}")
        done

        # Add the test suite root target
        targets+=("$target_prefix")

    done <<< "$suites"

    printf '%s\n' "${(u)targets[@]}" | sort
}

# =============================================================================
# Completion generators
# =============================================================================

# Generate global target completions
_mm_complete_global_targets() {
    _describe -t global-targets 'global target' _mm_global_target_specs
}

# Generate per-project target completions
_mm_complete_project_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local proj specs=()
    for proj in $(_mm_get_project_names "$project_root"); do
        specs+=("${proj}:Build project $proj")
        local spec
        for spec in "${_mm_project_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${proj}${suffix}:${desc}")
        done
    done

    (( ${#specs} )) && _describe -t project-targets 'project target' specs
}

# Generate per-library target completions
_mm_complete_library_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "library" ]] && continue
        specs+=("${asset_name}:Build library")
        local spec
        for spec in "${_mm_library_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t library-targets 'library target' specs
}

# Generate per-package target completions
_mm_complete_package_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "package" ]] && continue
        specs+=("${asset_name}:Build package")
        local spec
        for spec in "${_mm_package_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t package-targets 'package target' specs
}

# Generate per-extension target completions
_mm_complete_extension_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "extension" ]] && continue
        specs+=("${asset_name}:Build extension")
        local spec
        for spec in "${_mm_extension_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t extension-targets 'extension target' specs
}

# Generate per-test-suite target completions (structural + filesystem)
_mm_complete_test_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"

    local specs=()

    # Structural targets from config
    if [[ -n "$assets" ]]; then
        local asset_type asset_name
        while IFS='|' read -r asset_type asset_name; do
            [[ "$asset_type" != "testsuite" ]] && continue
            specs+=("${asset_name}:Run test suite")
            local spec
            for spec in "${_mm_testsuite_suffix_specs[@]}"; do
                local suffix="${spec%%:*}"
                local desc="${spec#*:}"
                specs+=("${asset_name}${suffix}:${desc}")
            done
        done <<< "$assets"
    fi

    # Filesystem-scanned test case targets
    local test_targets
    test_targets="$(_mm_get_test_targets "$project_root")"
    if [[ -n "$test_targets" ]]; then
        local t
        while IFS= read -r t; do
            [[ -n "$t" ]] && specs+=("${t}:Test case")
        done <<< "$test_targets"
    fi

    (( ${#specs} )) && _describe -t test-targets 'test target' specs
}

# Generate per-docker-image target completions
_mm_complete_docker_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "docker" ]] && continue
        specs+=("${asset_name}:Build docker image")
        local spec
        for spec in "${_mm_docker_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t docker-targets 'docker target' specs
}

# Generate per-webpack target completions
_mm_complete_webpack_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "webpack" ]] && continue
        specs+=("${asset_name}:Build webpack bundle")
        local spec
        for spec in "${_mm_webpack_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t webpack-targets 'webpack target' specs
}

# Generate per-vite bundle target completions
_mm_complete_vite_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "vite" ]] && continue
        specs+=("${asset_name}:Build vite bundle")
        local spec
        for spec in "${_mm_vite_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t vite-targets 'vite target' specs
}

# Generate per-verbatim target completions
_mm_complete_verbatim_targets() {
    local project_root
    project_root="$(_mm_find_project_root)"
    [[ -z "$project_root" ]] && return 1

    local assets
    assets="$(_mm_parse_assets "$project_root")"
    [[ -z "$assets" ]] && return 1

    local specs=()
    local asset_type asset_name
    while IFS='|' read -r asset_type asset_name; do
        [[ "$asset_type" != "verbatim" ]] && continue
        specs+=("${asset_name}:Copy verbatim files")
        local spec
        for spec in "${_mm_verbatim_suffix_specs[@]}"; do
            local suffix="${spec%%:*}"
            local desc="${spec#*:}"
            specs+=("${asset_name}${suffix}:${desc}")
        done
    done <<< "$assets"

    (( ${#specs} )) && _describe -t verbatim-targets 'verbatim target' specs
}

# Generate extern.{name}.info targets from make/extern/
_mm_complete_extern_targets() {
    local mm_home
    mm_home="$(_mm_find_mm_home)"
    [[ -z "$mm_home" ]] && return 1

    local extern_dir="$mm_home/make/extern"
    [[ ! -d "$extern_dir" ]] && return 1

    local specs=()
    local pkg_dir pkg
    for pkg_dir in "$extern_dir"/*(N/); do
        pkg="${pkg_dir:t}"
        specs+=("extern.${pkg}.info:Show ${pkg} package info")
    done

    (( ${#specs} )) && _describe -t extern-targets 'extern package target' specs
}

# Generate targets.{variant}.info targets from make/targets/
_mm_complete_variant_targets() {
    local mm_home
    mm_home="$(_mm_find_mm_home)"
    [[ -z "$mm_home" ]] && return 1

    local targets_dir="$mm_home/make/targets"
    [[ ! -d "$targets_dir" ]] && return 1

    local specs=()
    local variant_file variant
    for variant_file in "$targets_dir"/*.mm(N); do
        variant="${variant_file:t:r}"
        case "$variant" in
            init|model|rules) continue ;;
        esac
        specs+=("targets.${variant}.info:Show ${variant} variant info")
    done

    (( ${#specs} )) && _describe -t variant-targets 'variant info target' specs
}

# Generate languages.{lang}.info targets from make/languages/
_mm_complete_language_targets() {
    local mm_home
    mm_home="$(_mm_find_mm_home)"
    [[ -z "$mm_home" ]] && return 1

    local lang_dir="$mm_home/make/languages"
    [[ ! -d "$lang_dir" ]] && return 1

    local specs=()
    local lang_file lang
    for lang_file in "$lang_dir"/*.mm(N); do
        lang="${lang_file:t:r}"
        case "$lang" in
            init|model|rules) continue ;;
        esac
        specs+=("languages.${lang}.info:Show ${lang} language info")
    done

    (( ${#specs} )) && _describe -t language-targets 'language info target' specs
}

# =============================================================================
# Standalone target help command
# =============================================================================

mm-target-help() {
    local target="${1:-}"

    # Target description lookup (same data as the completion specs)
    _mm_target_description() {
        local t=$1
        case "$t" in
            help|mm.usage)       echo "Show usage information" ;;
            mm.banner)           echo "Print the mm version banner" ;;
            mm.config)           echo "Show makefile search path" ;;
            mm.info)             echo "Show important mm variables" ;;
            make.info)           echo "Show GNU Make variables" ;;
            builder.info)        echo "Show builder directory layout" ;;
            builder.info.help)   echo "List targets that print build layout" ;;
            builder.info.tmp)    echo "Show staging directory" ;;
            builder.info.prefix) echo "Show install prefix" ;;
            builder.info.bin)    echo "Show bin directory" ;;
            builder.info.doc)    echo "Show doc directory" ;;
            builder.info.inc)    echo "Show include directory" ;;
            builder.info.lib)    echo "Show lib directory" ;;
            builder.info.share)  echo "Show share directory" ;;
            builder.info.pyc)    echo "Show Python bytecode directory" ;;
            builder.info.staging) echo "Show staging directory" ;;
            platform.info)       echo "Show platform information (os, arch)" ;;
            host.info)           echo "Show host information (name, cores)" ;;
            user.info)           echo "Show user information (name, email)" ;;
            developer.info)      echo "Show developer options/overrides" ;;
            compilers.info)      echo "Show language-to-compiler map" ;;
            languages.info)      echo "List known languages" ;;
            suffixes.info)       echo "Show file extension to language map" ;;
            targets.info)        echo "Show target tag and variants" ;;
            extern.info)         echo "Show external package support" ;;
            extern.db.clean)     echo "Remove package database file" ;;
            projects)            echo "Build all projects" ;;
            projects.boot)       echo "Log build start and setup" ;;
            projects.shutdown)   echo "Log build finish" ;;
            projects.info)       echo "List known projects" ;;
            tests)               echo "Run all test suites" ;;
            tests.clean)         echo "Clean all test suites" ;;
            clean)               echo "Clean all projects and tests" ;;
            tidy)                echo "Delete backup files" ;;
            libraries.info)      echo "List known libraries" ;;
            packages.info)       echo "List known packages" ;;
            extensions.info)     echo "List known extensions" ;;
            tests.info)          echo "List known test suites" ;;
            docker-images.info)  echo "List known docker images" ;;
            webpack.info)        echo "List known webpack bundles" ;;
            vite.info)           echo "List known vite bundles" ;;
            *.directories)       echo "Create required directories" ;;
            *.assets)            echo "Build all assets" ;;
            *.clean)             echo "Clean artifacts" ;;
            *.info)              echo "Show metadata" ;;
            *.info.contents)     echo "Show asset contents" ;;
            *.help)              echo "Show documentation" ;;
            *.prerequisites)     echo "Build prerequisites" ;;
            *.headers.gateway)   echo "Publish gateway headers" ;;
            *.headers)           echo "Publish exported headers" ;;
            *.autogen.cleanup)   echo "Clean up autogenerated files" ;;
            *.cleangen)          echo "Remove autogenerated files" ;;
            *.archive)           echo "Build static archive (.a)" ;;
            *.dll)               echo "Build shared library (.so/.dylib)" ;;
            *.info.directories)  echo "Show directory layout" ;;
            *.info.sources)      echo "Show source files" ;;
            *.info.sources.cuda) echo "Show CUDA source files" ;;
            *.info.headers)      echo "Show header files" ;;
            *.info.objects)      echo "Show object files" ;;
            *.info.objects.cuda) echo "Show CUDA object files" ;;
            *.info.incdirs)      echo "Show include directories" ;;
            *.info.api)          echo "Show exported public headers" ;;
            *.info.languages)    echo "Show source languages and flags" ;;
            *.pyc)               echo "Byte-compile Python sources" ;;
            *.drivers)           echo "Export driver scripts" ;;
            *.config)            echo "Export configuration files" ;;
            *.meta)              echo "Build package metadata" ;;
            *.meta.source)       echo "Generate metadata .py source" ;;
            *.info.pyc)          echo "Show byte-compiled files" ;;
            *.info.pycdirs)      echo "Show byte-compile directories" ;;
            *.info.config)       echo "Show configuration files" ;;
            *.info.general)      echo "Show general metadata" ;;
            *.info.package)      echo "Show package install path" ;;
            *.info.meta)         echo "Show package metadata paths" ;;
            *.extension)         echo "Build the .so module" ;;
            *.capsule)           echo "Publish capsule headers" ;;
            *.module.init)       echo "Build module init from main" ;;
            *.module.init.clean) echo "Remove generated init file" ;;
            *.testcases)         echo "Build all test cases" ;;
            *.info.drivers)      echo "Show test case drivers" ;;
            *.info.staging.targets) echo "Show test make targets" ;;
            *.build)             echo "Run docker build" ;;
            *.run)               echo "Run docker container" ;;
            *.launch)            echo "Run docker interactively" ;;
            *.generated)         echo "Build relay-generated bundle" ;;
            *.chunks)            echo "Build external dependency chunks" ;;
            *.generate.prep)     echo "Prepare for generation" ;;
            *.static)            echo "Build static assets" ;;
            *.sources)           echo "Stage source files" ;;
            *.npm_modules)       echo "Install npm dependencies" ;;
            *.info.staged)       echo "List staged files" ;;
            *.info.installed)    echo "List installed files" ;;
            *.info.page)         echo "Show page paths" ;;
            *.info.root)         echo "Show pack prefix" ;;
            *.info.client)       echo "Show client path" ;;
            *.info.schema)       echo "Show schema path" ;;
            *.info.staging)      echo "Show staging prefix" ;;
            *.info.prefix)       echo "Show install prefix" ;;
            *.stage.config)      echo "Stage configuration files" ;;
            *.stage.dirs)        echo "Create staging directories" ;;
            *.stage.files)       echo "Stage source files" ;;
            *.stage.modules)     echo "Install/update node modules" ;;
            *.staging.prefix)    echo "Create staging area" ;;
            *.info.files)        echo "List source files" ;;
            *.info.staged.files) echo "List staged files" ;;
            *.info.staged.directories) echo "List staged directories" ;;
            *)                   echo "" ;;
        esac
    }

    if [[ -z "$target" ]]; then
        echo "Usage: mm-target-help <target>"
        echo ""
        echo "Global targets:"
        local spec
        for spec in "${_mm_global_target_specs[@]}"; do
            local name="${spec%%:*}"
            local desc="${spec#*:}"
            printf "  %-30s %s\n" "$name" "$desc"
        done
        return
    fi

    local desc
    desc="$(_mm_target_description "$target")"
    if [[ -n "$desc" ]]; then
        echo "$target -- $desc"
    else
        echo "No description available for '$target'"
    fi
}

# =============================================================================
# Main completion function
# =============================================================================

_mm() {
    local ret=1

    _arguments -C -s -S \
        '(- *)'{-h,--help}'[Show usage information]' \
        '(- *)--version[Show mm version]' \
        '--prefix=[Set install prefix]:prefix directory:_directories' \
        '--bldroot=[Set build root directory]:build directory:_directories' \
        '*--target=[Set build variant (comma-separated)]:variant:->target_value' \
        '--compilers=[Select compiler suite]:compiler:(gcc clang intel nvcc)' \
        '--local=[Load additional configuration]:config file:_files -g "*.mm"' \
        '--pkgdb=[Package database backend]:backend:(adhoc conda macports dpkg)' \
        '--setup[Show environment setup commands]' \
        '(-j --jobs --slots)'{-j,--jobs,--slots}'=[Number of parallel jobs]:jobs:({1..32})' \
        '--serial[Disable parallel builds]' \
        '(-n --dry)'{-n,--dry}'[Dry run - show commands without executing]' \
        '(--show)--show[Show commands as they execute]' \
        '(-q --quiet)'{-q,--quiet}'[Suppress non-essential output]' \
        '--color[Enable colored output]' \
        '--palette=[Output color palette]:palette:(builtin ansi dumb)' \
        '(-k --ignore)'{-k,--ignore}'[Continue on errors]' \
        '(-v --verbose)'{-v,--verbose}'[Verbose output]' \
        '--rules[Show make rules database]' \
        '--trace[Enable make tracing]' \
        '--make=[Path to make executable]:make:_command_names' \
        '--cfgdir=[Configuration directory]:config directory:_directories' \
        '--engine=[Build engine]:engine directory:_directories' \
        '--portinfo=[Port information directory]:portinfo directory:_directories' \
        '*:target:->targets' \
        && ret=0

    case "$state" in
        target_value)
            # Handle comma-separated target variants
            _values -s , 'build variant' \
                'debug[Debug build (-g)]' \
                'opt[Optimized build (-O3)]' \
                'shared[Position-independent code (-fPIC)]' \
                'prof[Profiling support (-pg)]' \
                'cov[Coverage instrumentation (--coverage)]' \
                'reldeb[Release with debug info (-g -O)]' \
                && ret=0
            ;;
        targets)
            _alternative \
                'global-targets:global target:_mm_complete_global_targets' \
                'project-targets:project target:_mm_complete_project_targets' \
                'library-targets:library target:_mm_complete_library_targets' \
                'package-targets:package target:_mm_complete_package_targets' \
                'extension-targets:extension target:_mm_complete_extension_targets' \
                'test-targets:test target:_mm_complete_test_targets' \
                'docker-targets:docker target:_mm_complete_docker_targets' \
                'webpack-targets:webpack target:_mm_complete_webpack_targets' \
                'vite-targets:vite target:_mm_complete_vite_targets' \
                'verbatim-targets:verbatim target:_mm_complete_verbatim_targets' \
                'extern-targets:extern package:_mm_complete_extern_targets' \
                'variant-targets:variant info:_mm_complete_variant_targets' \
                'language-targets:language info:_mm_complete_language_targets' \
                && ret=0
            ;;
    esac

    return ret
}

_mm "$@"

# ex: filetype=zsh
